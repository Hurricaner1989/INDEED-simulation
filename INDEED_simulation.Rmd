---
title: "Indeed simulation"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Generate simulation data 
```{r}
# install.packages("mvtnorm")
library(mvtnorm)

######## Generate simulation data ########
set.seed(42)
n <- 100 # sample size (per network)
p <- 10  # number of "genes" in the network.

#### Generate a precision matrix (pcor_matrix) for ground truth
## Generate random nodes
random_node <- rnbinom(p, p/2, prob=0.5)
random_node <- (random_node - mean(random_node))/max(random_node)
pcor_matrix_upper <- rep(0, p*(p-1)/2)
random_node_position <- sample(1:(p*(p-1)/2), size=p, replace=F)
pcor_matrix_upper[random_node_position] <- random_node

## Assign random nodes to the precision matrix
pcor_matrix <- diag(1, p)
pcor_matrix[upper.tri(pcor_matrix, diag=FALSE)] <- pcor_matrix_upper
pcor_matrix <- pcor_matrix + t(pcor_matrix) # symmetric
diag(pcor_matrix) <- rep(1, p) # diagonal equal to 1

## Generate a hub node in the middle
hub_node_position <- p/2
pcor_matrix[hub_node_position, c(1:(hub_node_position-1), (hub_node_position+1):p)] <- rbinom(p - 1, 1, 0.5) * (-1)^rbinom(p - 1, 1, 0.5) * runif(p - 1, 0.5, 1)
pcor_matrix[c(1:(hub_node_position-1), (hub_node_position+1):p), hub_node_position] <- pcor_matrix[hub_node_position, c(1:(hub_node_position-1),(hub_node_position+1):p)] # symmetric

## Adjust for a invertible precision matrix
min_eigen <- min(eigen(pcor_matrix)$val)
if(min_eigen <= 0) {
  pcor_matrix <- pcor_matrix + diag(1, p) * (abs(min_eigen) + 0.1) # 0.1?
  pcor_matrix <- cov2cor(pcor_matrix)
}

#### Generate simulation data from the precision matrix
## Get the covariance matrix
sigma <- solve(pcor_matrix)

## Simulation data from the covariance matrix
x_case <- rmvnorm(n, rep(0, p), sigma) 

## Simulation data from a control network containing no connections
x_control <- rmvnorm(n, rep(0, p), diag(p))

## Convert samples into a dataframe with rows for "genes" and columns for observations
x_df <- as.data.frame(t(rbind(x_case, x_control)))

#### Ground truth differential network map
heatmap(abs(pcor_matrix - diag(p)), 
        main = "True Diff. Network",
        symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE,
        col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

#### Differential network map by inverting the covariance matrix (only for n > p)
## Invert covariance matrix
precision_matrix_case <- solve(cov(x_case))
precision_matrix_control <- solve(cov(x_control))

## Get partial correlation for case group
pcor_matrix_case <- diag(1, p)
for (i in 1:(p-1)){
 for (j in (i+1):p){
   pcor_matrix_case[i,j] <- -precision_matrix_case[i,j]/sqrt(precision_matrix_case[i,i] * precision_matrix_case[j,j])
   pcor_matrix_case[j,i] <- pcor_matrix_case[i,j] 
 }
}

## Get partial correlation for control group
pcor_matrix_control <- diag(1, p)
for (i in 1:(p-1)){
 for (j in (i+1):p){
   pcor_matrix_control[i,j] <- -precision_matrix_control[i,j]/sqrt(precision_matrix_control[i,i] * precision_matrix_control[j,j])
   pcor_matrix_control[j,i] <- pcor_matrix_control[i,j]
 }
}

## Get map
heatmap(abs(pcor_matrix_case - pcor_matrix_control),
       main = "Inverse Covariance",
       symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE,
       col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

#### Remove unnecessary variables
rm(random_node, random_node_position, pcor_matrix_upper, hub_node_position, min_eigen, i, j, 
   pcor_matrix_case, pcor_matrix_control, precision_matrix_case, precision_matrix_control)
```

# Run INDEED
```{r}
# install.packages("devtools")
# library(devtools)
# devtools::install_github("ressomlab/INDEED")
library(INDEED)

######## Run INDEED with multiple testing correction (fdr) and not ########
#### Run INDEED with no fdr
id <- matrix(1:p, ncol = 1) 
y_class <- matrix(rep(c(0, 1), each = n), nrow = 1) # case = 0, control = 1
model_indeed_tempt <- select_rho_partial(x_df, y_class, id = id, error_curve = TRUE)
model_indeed_no_fdr <- partial_cor(data_list = model_indeed_tempt, rho_group1 = 'min', rho_group2 = "min",
                                   permutation = 1000, permutation_thres = 0.05, fdr = F)

## Get the differential network from INDEED with no fdr
network_indeed_no_fdr <- model_indeed_no_fdr$diff_network
network_matrix_indeed_no_fdr <- matrix(0, p, p)
if(nrow(network_indeed_no_fdr) > 0) {
  ## Node index and abs(Weight)
  network_matrix_indeed_no_fdr[cbind(network_indeed_no_fdr$Node1, network_indeed_no_fdr$Node2)] <- abs(network_indeed_no_fdr$Weight)
}
network_matrix_indeed_no_fdr <- network_matrix_indeed_no_fdr + t(network_matrix_indeed_no_fdr) # symmetric and diagonal equal to 0

#### Run INDEED with fdr
model_indeed_fdr <- partial_cor(data_list = model_indeed_tempt, rho_group1 = 'min', rho_group2 = "min",
                                   permutation = 1000, permutation_thres = 0.05, fdr = T)

## Get the differential network from INDEED with fdr
network_indeed_fdr <- model_indeed_fdr$diff_network
network_matrix_indeed_fdr <- matrix(0, p, p)
if(nrow(network_indeed_fdr) > 0) {
  ## Node index and abs(Weight)
  network_matrix_indeed_fdr[cbind(network_indeed_fdr$Node1, network_indeed_fdr$Node2)] <- abs(network_indeed_fdr$Weight)
}
network_matrix_indeed_fdr <- network_matrix_indeed_fdr + t(network_matrix_indeed_fdr) # symmetric and diagonal equal to 0

#### INDEED with no fdr differential network map
heatmap(network_matrix_indeed_no_fdr, 
        main = "Indeed_no_fdr",
        symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE,
        col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

#### INDEED with fdr differential network map
heatmap(network_matrix_indeed_fdr, 
        main = "Indeed_fdr",
        symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE,
        col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

#### Confusion matrix
# install.packages("caret")
library(caret)
## Get ground truth connections
pcor_matrix_off_diag <- pcor_matrix - diag(p)
pcor_connection <- c()
for (i in 1:(p-1)){
  for (j in (i+1):p){
    pcor_connection <- rbind(pcor_connection, c(i, j, pcor_matrix_off_diag[i,j]))
  }
}
pcor_connection <- data.frame(pcor_connection)
names(pcor_connection) <- c("Node1", "Node2", "PC")

## INDEED with no fdr confusion matrix
pcor_connection_union_no_fdr <- merge(pcor_connection, network_indeed_no_fdr, by = c("Node1","Node2"), all=T)
pcor_connection_union_no_fdr[is.na(pcor_connection_union_no_fdr)] <- 0
label_true <- rep(0, p*(p-1)/2)
label_true[which(pcor_connection_union_no_fdr$PC != 0)] = 1
label_indeed_no_fdr <- rep(0, p*(p-1)/2)
label_indeed_no_fdr[which(pcor_connection_union_no_fdr$Binary != 0)] = 1
metrics_indeed_no_fdr <- confusionMatrix(factor(label_indeed_no_fdr, levels = c('1', '0')), 
                                         factor(label_true, levels = c('1', '0')))
metrics_indeed_no_fdr 

## INDEED with fdr confusion matrix
pcor_connection_union_fdr <- merge(pcor_connection, network_indeed_fdr, by = c("Node1","Node2"), all=T)
pcor_connection_union_fdr[is.na(pcor_connection_union_fdr)] <- 0
label_indeed_fdr <- rep(0, p*(p-1)/2)
label_indeed_fdr[which(pcor_connection_union_fdr$Binary != 0)] = 1
metrics_indeed_fdr <- confusionMatrix(factor(label_indeed_fdr, levels = c('1', '0')), 
                                      factor(label_true, levels = c('1', '0')))
metrics_indeed_fdr 

#### Precision recall curve
# install.packages("PRROC")
library(PRROC)

## Get pr curve for INDEED with no fdr
pr_curve_indeed_no_fdr <- pr.curve(abs(pcor_connection_union_no_fdr$Weight[label_true == 1]), 
                                   abs(pcor_connection_union_no_fdr$Weight[label_true == 0]), 
                                   curve = TRUE)
plot(pr_curve_indeed_no_fdr)

## Get pr curve for INDEED with fdr
pr_curve_indeed_fdr <- pr.curve(abs(pcor_connection_union_fdr$Weight[label_true == 1]),
                                abs(pcor_connection_union_fdr$Weight[label_true == 0]), 
                                curve = TRUE)
plot(pr_curve_indeed_fdr)

#### Remove unnecessary variables
rm(model_indeed_tempt, i, j)

```

# Run DNAPATH
```{r}
# install.packages("dnapath")
library(dnapath)

######## Run DNAPATH ########
#### Run DNAPATH
x_df_dnapath <- t(x_df)
colnames(x_df_dnapath) <- id
rownames(x_df_dnapath) <- 1:nrow(x_df_dnapath)
model_dnapath <- dnapath(x = x_df_dnapath, groups = t(y_class), pathway_list = NULL)
edge_dnapath <- data.frame(summarize_edges(model_dnapath[[1]]))

## Get the differential network from DNAPATH
network_dnapath <- c()
k <- 1
for (i in 1:(p-1)){
  for (j in (i+1):p){
    network_dnapath <- rbind(network_dnapath, c(i, j, edge_dnapath[k, 3], edge_dnapath[k, 4]))
    k <- k + 1
  }
}
network_dnapath <- data.frame(network_dnapath)
names(network_dnapath) <- c("Node1", "Node2", "DC_Score", "P_Value")
network_dnapath <- network_dnapath[network_dnapath$P_Value < 0.05,]

## Get the differential network matrix form for map visulization
network_matrix_dnapath <- matrix(0, p, p)
if(nrow(network_dnapath) > 0) {
  ## Node index and DC_Score
  network_matrix_dnapath[cbind(network_dnapath$Node1, network_dnapath$Node2)] <- network_dnapath$DC_Score
}
network_matrix_dnapath <- network_matrix_dnapath + t(network_matrix_dnapath) # symmetric and diagonal equal to 0

#### Differential network map
heatmap(network_matrix_dnapath, 
        main = "Dnapath",
        symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE,
        col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

#### Confusion matrix
pcor_connection_union <- merge(pcor_connection, network_dnapath, by = c("Node1","Node2"), all=T)
pcor_connection_union[is.na(pcor_connection_union)] <- 0
label_dnapath <- rep(0, p*(p-1)/2)
label_dnapath[which(pcor_connection_union$P_Value != 0)] = 1
metrics_dnapath <- confusionMatrix(factor(label_dnapath, levels = c('1', '0')), 
                                   factor(label_true, levels = c('1', '0')))
metrics_dnapath 

#### Precision recall curve 
pr_curve_dnapath <- pr.curve(pcor_connection_union$DC_Score[label_true == 1], 
                             pcor_connection_union$DC_Score[label_true == 0], 
                             curve = TRUE)
plot(pr_curve_dnapath)

#### Remove unnecessary variables
rm(x_df_dnapath, edge_dnapath, i, j, k)
```




#JDINAC
#Load codes
```{r}
library(KernSmooth)
# install.packages("akima")
library(akima)
library(glmnet)

denPre2D <- function(edge,classLabel,DataFit,newData,method=c("integers","bandwidth")[2]){
  
  Index0 <- which(classLabel==0)
  Index1 <- which(classLabel==1)
  x <- DataFit[c(Index0,Index1),edge[1]]
  y <- DataFit[c(Index0,Index1),edge[2]]
  x0 <- newData[,edge[1]]
  y0 <- newData[,edge[2]]
  N <- max(c(x,y))
  coI <- 1:length(Index0)
  caI <- length(Index0)+(1:length(Index1))
  
  caWidth <- c(bw.nrd0(x[caI]),bw.nrd0(y[caI]))
  coWidth <- c(bw.nrd0(x[coI]),bw.nrd0(y[coI]))
  gridSize <- switch(method,
                     integers  = c(N, N),
                     bandwidth = ceiling(N / c(min(caWidth[1], coWidth[1]), 
                                               min(caWidth[2], coWidth[2]))))
  gridSize <- pmax(gridSize,10) # make sure there are at least 100 points in total

  caSmooth <- bkde2D(x=cbind(x[caI], y[caI]), bandwidth=caWidth,  gridsize=gridSize)
  caP <- caSmooth$fhat
  coSmooth <- bkde2D(x=cbind(x[coI], y[coI]), bandwidth=coWidth, gridsize=gridSize)
  coP <- coSmooth$fhat

  # make sure there are no zeros in the smooth function (since we will take a log of that)
  # caP[caP==0] <- min(caP[caP>0])/100
  caP <- pmax(caP, 1e-10)
  # coP[coP==0] <- min(coP[coP>0])/100
  coP <- pmax(coP, 1e-10)

  cafit <- bicubic(x=caSmooth$x1, y=caSmooth$x2, z=caP, x0=x0,y0=y0)
  cofit <- bicubic(x=coSmooth$x1, y=coSmooth$x2, z=coP, x0=x0,y0=y0)
  cafit$z <- pmax(cafit$z, 1e-10)
  cofit$z <- pmax(cofit$z, 1e-10)
  denPre <- log(cafit$z/cofit$z)
  denPre
}



jdinac <- function(EDGE,classLabel,DataFit,DataPre,zFit=NULL,zPre=NULL,nsplit=10,nfolds=5){
  
  if(missing(DataPre)) {
    DataPre <- DataFit
    zPre <- zFit
  }  
  if(!is.null(zFit) & !is.null(zPre)){
    Pre.Z <- jdinac.z(EDGE=EDGE,classLabel=classLabel,DataFit=DataFit,DataPre=DataPre,
                        zFit=zFit,zPre=zPre,nsplit=nsplit,nfolds=nfolds)
    yPre <- Pre.Z$yPre
    Eset <- Pre.Z$Eset
  } else if(nsplit<=0){       
    stop("nsplit must be positive integer")    
  } else {
    preY <- NULL
    vset <- NULL
    for(i in 1:nsplit){
      size0 <- sum(classLabel==0)
      size1 <- sum(classLabel==1)
      sn0 <- round(size0/2)
      sn1 <- round(size1/2)
      splitid <- c(sample(1:size0,sn0),sample((1:size1)+size0,sn1))
    
      cLabel <- classLabel[splitid]        
      denX <- apply(EDGE,1,denPre2D,classLabel=cLabel,DataFit=DataFit[splitid,],
                    newData=rbind(DataFit[-splitid,],DataPre))
      y <- classLabel[-splitid]
      cv.fit <- cv.glmnet(x=denX[1:length(y),], y=y, family = "binomial", nfolds=nfolds) 
      yp <- predict(cv.fit,newx=denX[-(1:length(y)),], s="lambda.min",type="response")
      preY <- cbind(preY,yp) 
      coefs <- which(coef(cv.fit,s="lambda.min")[-1] !=0)
      vset <- c(vset,coefs)
    
      cLabel <- classLabel[-splitid]        
      denX <- apply(EDGE,1,denPre2D,classLabel=cLabel,DataFit=DataFit[-splitid,],
                    newData=rbind(DataFit[splitid,],DataPre))
      y <- classLabel[splitid]
      cv.fit <- cv.glmnet(x=denX[1:length(y),], y=y, family = "binomial", nfolds=nfolds) 
      yp <- predict(cv.fit,newx=denX[-(1:length(y)),], s="lambda.min",type="response")
      preY <- cbind(preY,yp) 
      coefs <- which(coef(cv.fit,s="lambda.min")[-1] !=0)
      vset <- c(vset,coefs)     
    } 
    yPre <- rowMeans(preY) 
    numb <- table(vset)
    Vid <- as.numeric(rownames(numb))  
    Eset <- cbind(EDGE[Vid,],numb)
    Eset <- Eset[order(Eset[,3],decreasing=T),]
    colnames(Eset) <- c("row","col","numb")
  } 
  list(yPre=yPre,Eset=Eset) 
}



jdinac.z <- function(EDGE,classLabel,DataFit,DataPre,zFit,zPre,nsplit=10,nfolds=5){
  
  if(class(zFit)!="matrix" | class(zPre)!="matrix")
    stop("zFit and zPre must be 'matrix'")
  if(nsplit<=0){       
    stop("nsplit must be positive integer")  
  } else {
    preY <- NULL
    vset <- NULL
    for(i in 1:nsplit){
      size0 <- sum(classLabel==0)
      size1 <- sum(classLabel==1)
      sn0 <- round(size0/2)
      sn1 <- round(size1/2)
      splitid <- c(sample(1:size0,sn0),sample((1:size1)+size0,sn1))
    
      cLabel <- classLabel[splitid]
      denX <- apply(EDGE,1,denPre2D,classLabel=cLabel,DataFit=DataFit[splitid,],
                    newData=rbind(DataFit[-splitid,],DataPre))
      y <- classLabel[-splitid]
      zfit <- zFit[-splitid, ,drop=F]
      cv.fit <- cv.glmnet(x=cbind(zfit,denX[1:length(y),]), y=y, family = "binomial", nfolds=nfolds) 

      yp <- predict(cv.fit,newx=cbind(zPre,denX[-(1:length(y)),]), s="lambda.min",type="response")
      preY <- cbind(preY,yp) 
      coefs <- which(coef(cv.fit,s="lambda.min")[-(1:(1+ncol(zFit)))] !=0)
      vset <- c(vset,coefs)
    
      cLabel <- classLabel[-splitid]        
      denX <- apply(EDGE,1,denPre2D,classLabel=cLabel,DataFit=DataFit[-splitid,],
                    newData=rbind(DataFit[splitid,],DataPre))
      y <- classLabel[splitid]
      zfit <- zFit[splitid, ,drop=F]
      cv.fit <- cv.glmnet(x=cbind(zfit,denX[1:length(y),]), y=y, family = "binomial", nfolds=nfolds) 
      yp <- predict(cv.fit,newx=cbind(zPre,denX[-(1:length(y)),]), s="lambda.min",type="response")
      preY <- cbind(preY,yp) 
      coefs <- which(coef(cv.fit,s="lambda.min")[-(1:(1+ncol(zFit)))] !=0)
      vset <- c(vset,coefs)     
    } 
    yPre <- rowMeans(preY) 
    numb <- table(vset)
    Vid <- as.numeric(rownames(numb))  
    Eset <- cbind(EDGE[Vid,],numb)
    Eset <- Eset[order(Eset[,3],decreasing=T),]
    colnames(Eset) <- c("row","col","numb")
  } 
  list(yPre=yPre,Eset=Eset) 
}
```

#Simulation
```{r}
adjM=array(1,dim=c(p,p))
adjM[lower.tri(adjM,diag=T)] <- 0
EDGE <- which(adjM!=0, arr.ind=T)

difnet <- jdinac(EDGE=EDGE,classLabel=t(x),DataFit=t(df_expr),DataPre=t(df_expr),nsplit=5,nfolds=5)
# difnet$Eset

# Construct the DC network
dnw_JDINAC <- matrix(0, p, p)
if(nrow(difnet$Eset) > 0) {
  dnw_JDINAC[cbind(difnet$Eset[, 1], difnet$Eset[, 2])] <- difnet$Eset[, 3]#Weights
}
# Symmetrize.
dnw_JDINAC <- dnw_JDINAC + t(dnw_JDINAC)

# Heatmap of estiamted DC network with JDINAC
heatmap(abs(dnw_JDINAC), 
        main = "JDINAC",
        symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE, 
        col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

# confusion matrix
res5 = data.frame(difnet$Eset)
names(res5)=c("Node1","Node2","Weight")
together_intersect3=merge(pcor.origin, res5, by=c("Node1","Node2"),all=T)
together_intersect3[is.na(together_intersect3)] <- 0
label_jdinac <- rep(0, p*(p-1)/2)
label_jdinac[which(together_intersect3$Weight != 0)] = 1
metrics_jdinac <- confusionMatrix(factor(label_jdinac, levels = c('1', '0')),
                                  factor(label_true, levels = c('1', '0')))
metrics_jdinac

# pr curve 
pr <- pr.curve(together_intersect3$Weight[label_true == 1], together_intersect3$Weight[label_true == 0], curve = TRUE )
plot(pr)
```
#DGCA
```{r}
# devtools::install_github("andymckenzie/DGCA")
# install.packages("BiocManager")
# BiocManager::install("GO.db")
# BiocManager::install("impute")
# BiocManager::install("preprocessCore")
library("DGCA")
case<-rep(c(1,0),each=n)
control<-rep(c(0,1),each=n)
y<-matrix(c(case,control),ncol=2)
colnames(y)<-c("case","control")
ddcor_res = ddcorAll(inputMat = df_expr, design = y, compare = c("case", "control"), adjust = "perm")

# Construct the DC network
dnw_DGCA <- matrix(0, p, p)
if(nrow(ddcor_res) > 0) {
  dnw_DGCA[cbind(strtoi(ddcor_res[, 1]), strtoi(ddcor_res[, 2]))] <- abs(ddcor_res[, 7])#abs(z-score)
}
# Symmetrize.
dnw_DGCA <- dnw_DGCA + t(dnw_DGCA)

# Heatmap of estiamted DC network 
heatmap(abs(dnw_DGCA), 
        main = "DGCA",
        symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE, 
        col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

# Confusion matrix
# DGCA pvalue
res6 = data.frame(ddcor_res[,c(1, 2)])
names(res6) = c("Node1","Node2")
res6$Node1=as.numeric(res6$Node1)
res6$Node2=as.numeric(res6$Node2)
res6["Binary"] = rep(0, nrow(res6))
res6$Binary[ddcor_res$pValDiff<0.05 & ddcor_res$zScoreDiff<0] = -1
res6$Binary[ddcor_res$pValDiff<0.05 & ddcor_res$zScoreDiff>0] = 1
res6["Weight"] = abs(ddcor_res$zScoreDiff)#abs(z-score)
together_intersect4=merge(pcor.origin, res6, by=c("Node1","Node2"), all=T)
together_intersect4=together_intersect4[order(together_intersect4$Node1,together_intersect4$Node2),]
label_dgca <- rep(0, p*(p-1)/2)
label_dgca[which(together_intersect4$Binary != 0)] = 1
metrics_dgca <- confusionMatrix(factor(label_dgca, levels = c('1', '0')),
                                factor(label_true, levels = c('1', '0')))
metrics_dgca

# DGCA adjusted pvalue
res7 = data.frame(ddcor_res[,c(1, 2)])
names(res7) = c("Node1","Node2")
res7$Node1=as.numeric(res7$Node1)
res7$Node2=as.numeric(res7$Node2)
res7["Binary"] = rep(0, nrow(res7))
res7$Binary[ddcor_res$pValDiff_adj<0.05 & ddcor_res$zScoreDiff<0] = -1
res7$Binary[ddcor_res$pValDiff_adj<0.05 & ddcor_res$zScoreDiff>0] = 1
res7["Weight"] = abs(ddcor_res$zScoreDiff)#abs(z-score)
together_intersect5=merge(pcor.origin, res7, by=c("Node1","Node2"),all=T)
together_intersect5=together_intersect5[order(together_intersect5$Node1,together_intersect5$Node2),]
label_dgca_adj <- rep(0, p*(p-1)/2)
label_dgca_adj[which(together_intersect5$Binary != 0)] = 1
metrics_dgca_adj <- confusionMatrix(factor(label_dgca_adj, levels = c('1', '0')),
                                    factor(label_true, levels = c('1', '0')))
metrics_dgca_adj

# pr curve 
# DGCA pvalue
pr <- pr.curve(together_intersect4$Weight[label_true == 1], together_intersect4$Weight[label_true == 0], curve = TRUE )
plot(pr)
# DGCA adjusted pvalue
pr <- pr.curve(together_intersect5$Weight[label_true == 1], together_intersect5$Weight[label_true == 0], curve = TRUE )
plot(pr)
```

#DINGO
```{r}
# install.packages("iDINGO")
library(iDINGO)
y <- rep(c(0, 1), each = n)
dingo_res=dingo(t(df_expr), y, diff.score = TRUE, B=10) #default B=100, takes too long
dnw_dingo1=cbind(dingo_res$genepair,dingo_res$p.val)
dnw_dingo1$gene1=as.numeric(dnw_dingo1$gene1)
dnw_dingo1$gene2=as.numeric(dnw_dingo1$gene2)

# Construct the DC network
dnw_dingo <- matrix(0, p, p)
if(nrow(dnw_dingo1) > 0) {
  dnw_dingo[cbind(dnw_dingo1[, 1], dnw_dingo1[, 2])] <- abs(qnorm(1 - dnw_dingo1[,3]/2))#pvalue to zscore
}
# Symmetrize.
dnw_dingo  <- dnw_dingo  + t(dnw_dingo)

# Heatmap of estiamted DC network 
heatmap(abs(dnw_dingo), 
        main = "DINGO",
        symm = TRUE, Rowv = NA, Colv = NA, revC = TRUE, 
        col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50))

# Confusion matrix
res8 = data.frame(dnw_dingo1[,c(1, 2)])
names(res8) = c("Node1","Node2")
res8["Binary"] = rep(0, nrow(res8))
res8$Binary[dnw_dingo1[,3]<0.05] = 1
res8["Weight"] = abs(qnorm(1 - dnw_dingo1[,3]/2))
together_intersect6=merge(pcor.origin, res8, by=c("Node1","Node2"),all=T)
together_intersect6=together_intersect6[order(together_intersect6$Node1,together_intersect6$Node2),]
label_dingo <- rep(0, p*(p-1)/2)
label_dingo[which(together_intersect6$Binary != 0)] = 1
metrics_dingo <- confusionMatrix(factor(label_dingo, levels = c('1', '0')),
                                 factor(label_true, levels = c('1', '0')))
metrics_dingo

# pr curve 
pr <- pr.curve(together_intersect6$Weight[label_true == 1], together_intersect6$Weight[label_true == 0], curve = TRUE )
plot(pr)
```